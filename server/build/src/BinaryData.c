/* BinaryData.c generated by valac 0.32.1, the Vala compiler
 * generated from BinaryData.vala, do not modify */

/* For binary manipulation*/

#include <glib.h>
#include <glib-object.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define TYPE_BINARY_DATA (binary_data_get_type ())
#define BINARY_DATA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BINARY_DATA, BinaryData))
#define BINARY_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BINARY_DATA, BinaryDataClass))
#define IS_BINARY_DATA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BINARY_DATA))
#define IS_BINARY_DATA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BINARY_DATA))
#define BINARY_DATA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BINARY_DATA, BinaryDataClass))

typedef struct _BinaryData BinaryData;
typedef struct _BinaryDataClass BinaryDataClass;
typedef struct _BinaryDataPrivate BinaryDataPrivate;
typedef struct _ParamSpecBinaryData ParamSpecBinaryData;

struct _BinaryData {
	GTypeInstance parent_instance;
	volatile int ref_count;
	BinaryDataPrivate * priv;
};

struct _BinaryDataClass {
	GTypeClass parent_class;
	void (*finalize) (BinaryData *self);
};

struct _BinaryDataPrivate {
	guint8* _data;
	gint _data_length1;
	gint __data_size_;
};

struct _ParamSpecBinaryData {
	GParamSpec parent_instance;
};


static gpointer binary_data_parent_class = NULL;

gpointer binary_data_ref (gpointer instance);
void binary_data_unref (gpointer instance);
GParamSpec* param_spec_binary_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_binary_data (GValue* value, gpointer v_object);
void value_take_binary_data (GValue* value, gpointer v_object);
gpointer value_get_binary_data (const GValue* value);
GType binary_data_get_type (void) G_GNUC_CONST;
#define BINARY_DATA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_BINARY_DATA, BinaryDataPrivate))
enum  {
	BINARY_DATA_DUMMY_PROPERTY
};
BinaryData* binary_data_new (void);
BinaryData* binary_data_construct (GType object_type);
BinaryData* binary_data_new_WithArray (guint8* data, int data_length1);
BinaryData* binary_data_construct_WithArray (GType object_type, guint8* data, int data_length1);
static guint8* _vala_array_dup1 (guint8* self, int length);
gint binary_data_Size (BinaryData* self);
void binary_data_LTrim (BinaryData* self, guint len);
static guint8* _vala_array_dup2 (guint8* self, int length);
void binary_data_AddU8 (BinaryData* self, guint8 data);
static void _vala_array_add1 (guint8** array, int* length, int* size, guint8 value);
void binary_data_AddU16 (BinaryData* self, gushort data);
void binary_data_AddU32 (BinaryData* self, guint data);
void binary_data_AddArray (BinaryData* self, guint8* data, int data_length1);
guint8 binary_data_GetU8 (BinaryData* self, guint index);
gushort binary_data_GetU16 (BinaryData* self, guint index);
guint binary_data_GetU32 (BinaryData* self, guint index);
guint8* binary_data_GetArray (BinaryData* self, guint index, guint len, int* result_length1);
static guint8* _vala_array_dup3 (guint8* self, int length);
guint8* binary_data_ToArray (BinaryData* self, int* result_length1);
static guint8* _vala_array_dup4 (guint8* self, int length);
static void binary_data_finalize (BinaryData* obj);


BinaryData* binary_data_construct (GType object_type) {
	BinaryData* self = NULL;
	guint8* _tmp0_ = NULL;
	self = (BinaryData*) g_type_create_instance (object_type);
	_tmp0_ = g_new0 (guint8, 0);
	self->priv->_data = (g_free (self->priv->_data), NULL);
	self->priv->_data = _tmp0_;
	self->priv->_data_length1 = 0;
	self->priv->__data_size_ = self->priv->_data_length1;
	return self;
}


BinaryData* binary_data_new (void) {
	return binary_data_construct (TYPE_BINARY_DATA);
}


static guint8* _vala_array_dup1 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


BinaryData* binary_data_construct_WithArray (GType object_type, guint8* data, int data_length1) {
	BinaryData* self = NULL;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	self = (BinaryData*) g_type_create_instance (object_type);
	_tmp0_ = data;
	_tmp0__length1 = data_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup1 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	self->priv->_data = (g_free (self->priv->_data), NULL);
	self->priv->_data = _tmp1_;
	self->priv->_data_length1 = _tmp1__length1;
	self->priv->__data_size_ = self->priv->_data_length1;
	return self;
}


BinaryData* binary_data_new_WithArray (guint8* data, int data_length1) {
	return binary_data_construct_WithArray (TYPE_BINARY_DATA, data, data_length1);
}


gint binary_data_Size (BinaryData* self) {
	gint result = 0;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	result = _tmp0__length1;
	return result;
}


static guint8* _vala_array_dup2 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


void binary_data_LTrim (BinaryData* self, guint len) {
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint _tmp1_ = 0U;
	guint8* _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	_tmp1_ = len;
	_tmp2_ = self->priv->_data;
	_tmp2__length1 = self->priv->_data_length1;
	_tmp3_ = ((_tmp0_ + ((gint) _tmp1_)) != NULL) ? _vala_array_dup2 (_tmp0_ + ((gint) _tmp1_), _tmp2__length1 - ((gint) _tmp1_)) : ((gpointer) (_tmp0_ + ((gint) _tmp1_)));
	_tmp3__length1 = _tmp2__length1 - ((gint) _tmp1_);
	self->priv->_data = (g_free (self->priv->_data), NULL);
	self->priv->_data = _tmp3_;
	self->priv->_data_length1 = _tmp3__length1;
	self->priv->__data_size_ = self->priv->_data_length1;
}


static void _vala_array_add1 (guint8** array, int* length, int* size, guint8 value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (guint8, *array, *size);
	}
	(*array)[(*length)++] = value;
}


void binary_data_AddU8 (BinaryData* self, guint8 data) {
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8 _tmp1_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	_tmp1_ = data;
	_vala_array_add1 (&self->priv->_data, &self->priv->_data_length1, &self->priv->__data_size_, _tmp1_);
}


void binary_data_AddU16 (BinaryData* self, gushort data) {
	gint len = 0;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gint _tmp1_ = 0;
	guint8* _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	gushort _tmp3_ = 0U;
	guint8 _tmp4_ = 0U;
	guint8* _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	gushort _tmp6_ = 0U;
	guint8 _tmp7_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	len = _tmp0__length1;
	_tmp1_ = len + 2;
	self->priv->_data = g_renew (guint8, self->priv->_data, len + 2);
	(_tmp1_ > self->priv->_data_length1) ? memset (self->priv->_data + self->priv->_data_length1, 0, sizeof (guint8) * (_tmp1_ - self->priv->_data_length1)) : NULL;
	self->priv->_data_length1 = _tmp1_;
	self->priv->__data_size_ = _tmp1_;
	_tmp2_ = self->priv->_data;
	_tmp2__length1 = self->priv->_data_length1;
	_tmp3_ = data;
	_tmp2_[len] = (guint8) (_tmp3_ >> 8);
	_tmp4_ = _tmp2_[len];
	_tmp5_ = self->priv->_data;
	_tmp5__length1 = self->priv->_data_length1;
	_tmp6_ = data;
	_tmp5_[len + 1] = (guint8) (_tmp6_ & 0xFF);
	_tmp7_ = _tmp5_[len + 1];
}


void binary_data_AddU32 (BinaryData* self, guint data) {
	g_return_if_fail (self != NULL);
}


void binary_data_AddArray (BinaryData* self, guint8* data, int data_length1) {
	gint len = 0;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	gint _tmp2_ = 0;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guint8* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	guint8* _tmp5_ = NULL;
	gint _tmp5__length1 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	len = _tmp0__length1;
	_tmp1_ = data;
	_tmp1__length1 = data_length1;
	_tmp2_ = len + _tmp1__length1;
	self->priv->_data = g_renew (guint8, self->priv->_data, len + _tmp1__length1);
	(_tmp2_ > self->priv->_data_length1) ? memset (self->priv->_data + self->priv->_data_length1, 0, sizeof (guint8) * (_tmp2_ - self->priv->_data_length1)) : NULL;
	self->priv->_data_length1 = _tmp2_;
	self->priv->__data_size_ = _tmp2_;
	_tmp3_ = self->priv->_data;
	_tmp3__length1 = self->priv->_data_length1;
	_tmp4_ = data;
	_tmp4__length1 = data_length1;
	_tmp5_ = data;
	_tmp5__length1 = data_length1;
	memcpy (&_tmp3_[len], &_tmp4_[0], (gsize) _tmp5__length1);
}


guint8 binary_data_GetU8 (BinaryData* self, guint index) {
	guint8 result = 0U;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint _tmp1_ = 0U;
	guint8 _tmp2_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	_tmp1_ = index;
	_tmp2_ = _tmp0_[_tmp1_];
	result = _tmp2_;
	return result;
}


gushort binary_data_GetU16 (BinaryData* self, guint index) {
	gushort result = 0U;
	gushort res = 0U;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint _tmp1_ = 0U;
	guint8 _tmp2_ = 0U;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guint _tmp4_ = 0U;
	guint8 _tmp5_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	_tmp1_ = index;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp3_ = self->priv->_data;
	_tmp3__length1 = self->priv->_data_length1;
	_tmp4_ = index;
	_tmp5_ = _tmp3_[_tmp4_ + 1];
	res = (gushort) ((_tmp2_ << 8) + _tmp5_);
	result = res;
	return result;
}


guint binary_data_GetU32 (BinaryData* self, guint index) {
	guint result = 0U;
	guint res = 0U;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint _tmp1_ = 0U;
	guint8 _tmp2_ = 0U;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guint _tmp4_ = 0U;
	guint8 _tmp5_ = 0U;
	guint8* _tmp6_ = NULL;
	gint _tmp6__length1 = 0;
	guint _tmp7_ = 0U;
	guint8 _tmp8_ = 0U;
	guint8* _tmp9_ = NULL;
	gint _tmp9__length1 = 0;
	guint _tmp10_ = 0U;
	guint8 _tmp11_ = 0U;
	g_return_val_if_fail (self != NULL, 0U);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	_tmp1_ = index;
	_tmp2_ = _tmp0_[_tmp1_];
	_tmp3_ = self->priv->_data;
	_tmp3__length1 = self->priv->_data_length1;
	_tmp4_ = index;
	_tmp5_ = _tmp3_[_tmp4_ + 1];
	_tmp6_ = self->priv->_data;
	_tmp6__length1 = self->priv->_data_length1;
	_tmp7_ = index;
	_tmp8_ = _tmp6_[_tmp7_ + 2];
	_tmp9_ = self->priv->_data;
	_tmp9__length1 = self->priv->_data_length1;
	_tmp10_ = index;
	_tmp11_ = _tmp9_[_tmp10_ + 3];
	res = (guint) ((((_tmp2_ << 24) + (_tmp5_ << 16)) + (_tmp8_ << 8)) + _tmp11_);
	result = res;
	return result;
}


static guint8* _vala_array_dup3 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


guint8* binary_data_GetArray (BinaryData* self, guint index, guint len, int* result_length1) {
	guint8* result = NULL;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint _tmp1_ = 0U;
	guint _tmp2_ = 0U;
	guint8* _tmp3_ = NULL;
	gint _tmp3__length1 = 0;
	guint8* _tmp4_ = NULL;
	gint _tmp4__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	_tmp1_ = index;
	_tmp2_ = len;
	_tmp3_ = ((_tmp0_ + ((gint) _tmp1_)) != NULL) ? _vala_array_dup3 (_tmp0_ + ((gint) _tmp1_), ((gint) _tmp2_) - ((gint) _tmp1_)) : ((gpointer) (_tmp0_ + ((gint) _tmp1_)));
	_tmp3__length1 = ((gint) _tmp2_) - ((gint) _tmp1_);
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


static guint8* _vala_array_dup4 (guint8* self, int length) {
	return g_memdup (self, length * sizeof (guint8));
}


guint8* binary_data_ToArray (BinaryData* self, int* result_length1) {
	guint8* result = NULL;
	guint8* _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	guint8* _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	guint8* _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_data;
	_tmp0__length1 = self->priv->_data_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup4 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	_tmp2_ = _tmp1_;
	_tmp2__length1 = _tmp1__length1;
	if (result_length1) {
		*result_length1 = _tmp2__length1;
	}
	result = _tmp2_;
	return result;
}


static void value_binary_data_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_binary_data_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		binary_data_unref (value->data[0].v_pointer);
	}
}


static void value_binary_data_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = binary_data_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_binary_data_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_binary_data_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		BinaryData* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = binary_data_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_binary_data_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	BinaryData** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = binary_data_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_binary_data (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecBinaryData* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_BINARY_DATA), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_binary_data (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_BINARY_DATA), NULL);
	return value->data[0].v_pointer;
}


void value_set_binary_data (GValue* value, gpointer v_object) {
	BinaryData* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_BINARY_DATA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_BINARY_DATA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		binary_data_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		binary_data_unref (old);
	}
}


void value_take_binary_data (GValue* value, gpointer v_object) {
	BinaryData* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_BINARY_DATA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_BINARY_DATA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		binary_data_unref (old);
	}
}


static void binary_data_class_init (BinaryDataClass * klass) {
	binary_data_parent_class = g_type_class_peek_parent (klass);
	((BinaryDataClass *) klass)->finalize = binary_data_finalize;
	g_type_class_add_private (klass, sizeof (BinaryDataPrivate));
}


static void binary_data_instance_init (BinaryData * self) {
	self->priv = BINARY_DATA_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void binary_data_finalize (BinaryData* obj) {
	BinaryData * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_BINARY_DATA, BinaryData);
	g_signal_handlers_destroy (self);
	self->priv->_data = (g_free (self->priv->_data), NULL);
}


GType binary_data_get_type (void) {
	static volatile gsize binary_data_type_id__volatile = 0;
	if (g_once_init_enter (&binary_data_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_binary_data_init, value_binary_data_free_value, value_binary_data_copy_value, value_binary_data_peek_pointer, "p", value_binary_data_collect_value, "p", value_binary_data_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (BinaryDataClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) binary_data_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BinaryData), 0, (GInstanceInitFunc) binary_data_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType binary_data_type_id;
		binary_data_type_id = g_type_register_fundamental (g_type_fundamental_next (), "BinaryData", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&binary_data_type_id__volatile, binary_data_type_id);
	}
	return binary_data_type_id__volatile;
}


gpointer binary_data_ref (gpointer instance) {
	BinaryData* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void binary_data_unref (gpointer instance) {
	BinaryData* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		BINARY_DATA_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}



